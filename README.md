Download Link: https://assignmentchef.com/product/solved-solvednetwork-servers-and-server-performance-_-solution
<br>
This assignment gives you a chance to become familiar with concurrent network clients, servers, covering topics including threads, synchronization, wait/notify (monitor), asynchronous I/O, and benchmarking. by uploading to classes Protocol The server that we will design is a simpliﬁed version of HTTP 1.0. The most basic application message, encoded in ASCII, from the client to the server is: GET

example code provided in class. Following Apache conﬁguration style (http://httpd.apache.org/docs/2.4/vhosts/examples.html; note that we implement a single server name, not multiple, as the example conﬁguration shows), we program each server by reading a conﬁguration ﬁle: %java A great way to learn about your design is to compare with other designs. You need to read the docuemnts or code of two related frameworks: xsocket and netty. Part 3.2(a): Comparison with xsocket Although xsocket is no longer under active development, it provides a design alternative. Please read the source code and document of x-Socket, a high performance software library for reusable, asynchronous I/O servers. Please discuss in your report the following questions (please refer to the speciﬁc location when you refer to its document or source code: How many dispatchers does x-Socket allow? If multiple, how do the dispatchers share workload? What is the basic ﬂow of a dispatcher thread? What is the calling sequence until the onData method of EchoHandler (see EchoHandler, EchoServer, and EchoServerTest) is invoked? Please check this link for testing code: http://sourceforge.net/p/xsocket/code/HEAD/tree/xsocket/core/trunk/src/test/java/org/xsocket/connection/ How does x-Socket implement Idle timeout of a connection? Please give an example of how the library does testing (see http://sourceforge.net/p/xsocket/code/HEAD/tree/xsocket/core/trunk/src/test/java/org/xsocket/connection/EchoServerTest.java for an example). Please describe how you may test your server with idle timeout? Part 3.2(b): Comparison with Netty Netty is another Java async IO framework used by many; see for example use cases. Please read Netty user’s guide and answer the following questions: Netty provides multiple event loop implementations. In a typical server channel setting, two event loop groups are created, with one typically called the boss group and the second worker group. What are they? How does Netty achieve synchronization among them? Method calls such as bind return ChannelFuture. Please describe how one may implement the sync method of a future. Instead of using ByteBuffer, Netty introduces a data structure called ByteBuf. Please give one key difference between ByteBuffer and ByteBuf. A major novel, interesting feature of Netty which we did not cover in class is ChannelPipeline. A pipeline may consist of a list of ChannelHander. Compare HTTP Hello World Server and HTTP Snoop Server, what are the handlers that each insert? Please scan Netty implementation and give a high-level description of how ChannelPipeline is implemented. Part 4: Performance Benchmarking One important computer systems skill is to evaluate the performance of design alternatives. In this assignment, we conduct performance evaluation of the alternatives: To conduct the testing, you will need to setup the DocumentRoot at the server. It is highly recommended that you generate a number of ﬁles of different sizes under DocumentRoot named such as ﬁle1.html, ﬁle2.html, …, ﬁle1000.html. If you download gen.tar, and untar it (tar -xvf gen.tar), you will see a directory named doc-root and a directory named request-patterns. To compare the performance with Apache, we will use the department zoo Apache server. We will use /home/httpd/html/zoo/classes/cs433/web/wwwroot to store testing ﬁles. Suppose we want to fetch /home/httpd/html/zoo/classes/cs433/web/www-root/html-small/doc1.html. To use the department Apache server, since the department server has set DocumentRoot as /home/httpd/html/zoo, the URL should be: http://zoo.cs.yale.edu/classes/cs433/web/www-root/html-small/doc1.html To use your server, suppose you set the DocumentRoot as /home/httpd/html/zoo/classes/cs433/web/www-root, and you run your server on cicada.cs.yale.edu at port 9876. Then the URL is: http://cicada.cs.yale.edu:9876/html-small/doc1.html For the test, you will need to generate a request ﬁle for the client. The request pattern can have a major impact on your server performance (how requests repeat). The TA will use a Pareto distribution to generate request patterns to test your server. You can write a simple Java program or script to generate the request. You should vary the client parallel (see Client command line above) with a reasonable increment schedule (e.g., 1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 60, 70, …). A reasonable test time is 60 to 120 seconds. You can write a simple script to automate this task. For multithreaded server, please try two thread pool sizes: one small and one large. Part 5: Report You should submit a report on your server design. Please answer any question we speciﬁed above. Please report the measured performance of both Apache and your best server for these performance metrics: throughput and (mean) delay. You can use open ofﬁce or gnuplot to generate ﬁgures. Below is an example ﬁgure showing the performance of multiple servers.The TA will benchmark all servers and pick the one with the highest throughput. This server will receive a bonus of 25%. Submission Please submit using class server. Please include README to tell the TA the directory structure, e.g., which ﬁle is the report. Please generate a single jar ﬁle containing all of your ﬁles. Suggestions During your async i/o design, think how you implement a ﬁnite state machine to handle each request (e.g., initial state after accepting a connection, what other states). Java async i/o does not allow you to select events on a ﬁle channel. There are can be multiple design options to handle ﬁle i/o: Use standard ﬁle i/o by assuming that ﬁle system is fast and will not become bottleneck; Try out mapped ﬁle i/o: FileInputStream fin = new FileInputStream(args[0]); FileChannel in = fin.getChannel(); ByteBuffer input = in.map(FileChannel.MapMode.READ_ONLY, 0, in.size()); Try out direct transfer: See FileChannel.transferTo; Use standard ﬁle i/o and use a thread pool to help with reading ﬁles.